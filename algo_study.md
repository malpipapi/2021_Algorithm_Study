# 알고리즘 스터디 정리
+ DFS
+ BFS
+ 이분탐색
+ 완전탐색
+ 그래프(플로이드 워셜,다익스트라)
+ 누적합
+ 그리디
+ 힙
+ 트리
+ 투포인터
+ 해쉬
+ 집합
+ 문자열
----------
# 탐색
+ 탐색이란?   
-많은 양의 데이터가 있을 때 원하는 데이터를 찾는 과정이다.
다양한 알고리즘에서 특정 조건에맞는 데이터가 존재하는지 만약 존재하는지 존재한다면 어떤 위치에 존재하는지에 대해 탐색알고리즘을 사용한다.

+ 대표적인 탐색 알고리즘:DFS,BFS
+ 알아야 할 자료구조:스택,큐
+ 스택 자료구조:선입후출의 자료구조(먼저 입력되는 데이터가 나중에 나간다)-입구와 출구가 동일한 형태로 스택을 시각화
+ 큐:큐는 입구와 출구가 모두 뚫려 있는 터널과 같은 형태
------
# DFS(Depth First Search)
+ DFS란?   
-깊이 우선 탐색,깊은 부분을 우선적으로 탐색하는 알고리즘
+ 알고가면 좋은 함수   
-재귀함수(recursive Function):자기 자신을 다시 호출하는 함수.dfs를 할 때 자주 사용하는 함수.재귀함수의 종료조건을 반드시 명시해야 한다.(무한히 호출되면 오류가 남).모든 재귀 함수는 반복문을 이용하여 동일한 기능을 구현할 수 있습니다.

+ DFS알고리즘 실행 순서
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리를 한다.방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다.
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복
------
# BFS(Breadth First Search)
+ BFS란?   
-너비 우선 탐색이라고 부르며, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘.큐 자료구조를 이용

+ BFS 알고리즘 실행 순서
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다.
2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리합니다.
3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.

+ **BFS는 특정 조건의 최단경로에서 자주 사용됩니다**
+ **간선의 길이가 같을 때,최단거리를 탐색할 때 사용**
------
# 최단경로
+ 최단경로 알고리즘은 가장 짧은 경로를 찾는 알고리즘을 의미합니다.

## 다양한 문제상황
+ 한 지점에서 다른 한 지점까지의 최단 경로
+ 한 지점에서 다른 모든 지점까지의 최단 경로
+ 모든 지점에서 다른 모든 지점가지의 최단 경로   

특징
+ 각 지점은 그래프에서 노드로 표현
+ 지점 간 연결된 도로는 그래프에서 간선으로 표현
------
# 다익스트라 알고리즘
## 다익스트라 알고리즘의 특징
+ 그리디 알고리즘:매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해 임의의 과정을 반복합니다.
+ 단계를 거치며 한 번 처리된 노드의 최단 거리는 고정되어 더 이상 바뀌지 않습니다.(한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있습니다.)
+ 다익스트라 알고리즘을 수행한 뒤에 테이블에 각 노드까지의 최단 거리 정보가 저장됩니다.(완벽한 형태의 최단 경로를 구하려면 소스코드에 추가적인 기능을 더 넣어야 합니다.)

## 다익스트라 최단경로 알고리즘의 동작과정
1. 출발 노드를 설정합니다.
2. 최단 거리 테이블을 초기화합니다.(자기 자신으로 가는 노드는 0으로 설정)
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택합니다.
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신합니다.
5. 위 과정에서 3번과 4번을 반복합니다.
   
## 다익스트라 최단 경로 알고리즘의 개요
+ 특정한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로를 계산합니다.
+ 다익스트라 최단 경로 알고리즘은 음의 간선인 없을 때 정상적으로 동작합니다.(현실 세계의 도로(간선)은 음의 간선으로 표현되지 않습니다.)
+ 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류됩니다.(매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정을 반복합니다.)

## 간단한 구현방법
+ 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다 1차원 테이블의 모든 원소를 확인(순차 탐색)합니다.
   1. 총 O(V)번 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야 합니다.
   2. 따라서 전체 시간 복잡도는 O(v^2)입니다. *v는 노드의 개수) 
   3. 일반적으로 코딩테스트의 최단 경로 문제에서 전체 노드의 개수가 5000개 이하라면 이 코드로 문제를 해결할 수 있습니다.(하지만 노드의 개수가 10000개를 넘어가는 문제라면 시간 초과가 납니다.)

## 개선된 다익스트라를 구현하기 위해 미리 알면 좋은 자료구조
+ 우선순위 큐(Priority Queue)   
  1. 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조
  2. 예를 들어 여러 개의 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내어 확인해야 하는 경우에 우선순위 큐를 이용할 수 있습니다.

+ 힙(Heap)
    1. 우선순위 큐를 구현하기 위해 사용하는 자료구조 중 하나.
    2. 최소힙과 최대힙이 있습니다.
    3. 다익스트라 최단경로 알고리즘을 포함해 다양한 알고리즘에서 사용됩니다.

## 개선된 다익스트라 알고리즘 구현방법
1. 단계마다 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택하기 위해 힙 자료구조를 이용합니다.
2. 다익스트라 알고리즘이 동작하는 기본 원리는 동일합니다.
+ 현재 가장 가까운 노드를 저장해 놓기 위해서 힙 자료구조를 추가적으로 이용한다는 점이 다릅니다.
+ 현재의 최단 거리가 가장 짧은 노드를 선택해야 하므로 최소 힙을 사용합니다.
3. 거리순으로 우선순위를 정해준다.

## 개선된 다익스트라의 성능 분석
+ 힙 자료구조를 이용하는 다익스트라 알고리즘의 시작복잡도는 O(ElogN)입니다.
+ 노드를 하나씩 꺼내 검사하는 반복문은 노드의 개수 V이상의 횟수로는 처리되지 않습니다.(결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총 횟수는 최대 간선의 개수(E)만큼 연산이 수행될 수 있습니다.)
+ 직관적으로 전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사합니다.(시간 복잡도를 O(ElogE)로 판단할 수 있습니다.)
+ 중복 간선을 포함하지 않는 경우를 이를 O(ElogN)로 정리할 수 있습니다.
+ ***O(ElogE) ->O(ElogV^2)->O(2ElogV)->O(ElogV)***
------
# 플로이드 워셜(Floyd Washar)
## 플로이드 워셜 알고리즘 개요
1. 모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산합니다.
2. 플로이드 워셜 알고리즘은 다익스트라 알고리즘과 마찬가지로 단계별로 거쳐가는 노드를 기준으로 알고리즘을 수행합니다.
   + 다만 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않습니다.
3. 플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장합니다.
4. .플로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속합니다.

## 플로이드 워셜 구현
1. 각 단계마다 특정한 노드k를 거쳐 가는 경우를 확인합니다.
2. a에서 b로 가는 최단 거리보다 a에서 k를 거쳐 b로 가는 거리가 더 짧은지 검사합니다.
+ **점화식:Dab - min(Dab,Dak +Dkb)**

## 플로이드 워셜 성능 분석
1. 노드의 개수가 N개일 때 알고리즘상으로. N번의 단계를 수행합니다.
2. 각 단계마다O(N^2)의 연산을 통해 현재 노드를 거쳐 가는 모든 경로를 고려합니다.
3. 따라서 플로이드 워셜 알고리즘 총 시간 복잡도는 O(N^3)입니다.
    + **500개 이하의 노드에서만 사용한다.**
------
# 그리디 알고리즘
## 그리디 알고리즘이란?
+ 그리디 알고리즘은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미합니다.
+ 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구합니다.
+ 그리디 해법은 그 정당성 분석이 중요합니다.
+ 단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토합니다.
+ 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많습니다.
+ 하지만 코딩테스트에서의 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됩니다.

## 그리디 알고리즘 문제리스트
+ 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭
+ 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
+ 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
+ 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
+ 적절한 라이브러리를 찾아서 사용해야 하는 문제
------
# 이진탐색
+ 순차탐색:리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 확인하는 방법
+ 이진탐색:정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법.
+ **이진 탐색은 시작점,끝점,중간점을 이용하여 탐색 범위를 설정합니다.**

## 이진탐색의 시간 복잡도
+ 단계마다 탐색 범위를 2로 나누는 것과 동일하므로 연산 횟수는 log2N에 비례합니다.
+ 예를 들어 초기 데이터 개수가 32개 일때,이상적으로 1단계를 거치면 16개가량의 데이터만 남습니다.
  + 2단계:8개,3단계:4개
+ 다시 말해 이진 탐색은 탐색 범위를 절반씩 줄이며, 시간 복잡도는 O(logN)을 보장합니다.
------
# 파라메트릭 서치
+ 파라메트릭 서치란 최적화 문제를 결정문제(예,아니오)로 바꾸어 해결하는 기법입니다.
+ 특정한 조건을 만족하는 가장 알맞은 값을 빠르게 찾는 최적화 문제에 사용됩니다.
+ 일반적으로 코딩테스트에서 파라메트릭 서치 문제는 이진 탐색을 이용하여 해결할 수 있습니다.

# 투 포인터(Two Pointers)
+ 투포인터 알고리즘은 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미합니다.
+ 흔히 2,3,4,5,6,7번 학생을 지목해야 할 때 간단히 ‘2번부터 7번까지의 학생’이라고 부르곤 합니다.
+ 리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 시작점과 끝점 2개의 점으로 접근할 데이터의 범위를 표현할 수 있습니다.

## 특정한 합을 가지는 부분 연속 수열 찾기:문제 해결 아이디어
+ 투포인터를 활용하여 다음과 같은 알고리즘으로 문제를 해결할 수 있습니다.
  1. 시작점과 끝점이 첫 번째 원소의 인덱스를 가리키도록 한다.
  2. 현재 부분 합이 M과 같다면, 카운트한다.
  3. 현재 부분 합이 M보다 작다면,end를 1증가시킨다.
  4. 현재 부분 합이 M보다 크거나 같다면,start를 1 증가시킨다.
  5. 모든 경우를 확인할 때까지 2번부터 4번의 과정을 반복한다.
```java
package java_algo;
import java.util.*;

public class Interval_sum {
	public static int n = 5;
	public static int m =5;
	public static int[] arr = {1,2,3,2,5};
	public static void main(String[] args) {
		int cnt = 0,intervalSum = 0,end =0;
		for(int start =0;start <n;start++) {
			while(intervalSum <m && end <n) {
				intervalSum += arr[end];
				end += 1;
			}
			if(intervalSum == m) {
				cnt += 1;
			}
			intervalSum -= arr[start];
		}
		System.out.println(cnt);
	}

}
```
------
# 구간합(Interval Sum)
## 구간합이란?
  연속적으로 나열된 N개의 수가 있을 때 특정 구간의 모든 수를 합한 값을 계산하는 문제
+ 예를 들어 5개의 데이터로 구성된 수열{10,20,30,40,50}이 있다고 가정한다.
+ 두 번째 수부터 네 번째 수까지의 합은 20+30+40 =90 이다.

## 구간합 빠르게 계산하기 문제
+ N개의 정수로 구성된 수열이 있다.
+ M개의 쿼리 정보가 주어집니다.
  + 각 쿼리는 Left와 Right으로 구성됩니다.
  + 각 쿼리에 대하여 [Left,Right]구간에 포함된 데이터들의 합을 출력해야 합니다.
+ 수행 시간 제한은O(N+M)입니다.
------
# 접두사 합(Prefix Sum)
## 접두사 합이란?
배열의 맨 앞부터 특정 위치까지의 합을 미리 구해 놓은 것

## 접두사 합을 활용한 알고리즘
+ N개의 수 위치 각각에 대하여 접두사 합을 계산하여 P에 저장한다.
+ 매 M개의 쿼리 정보를 확인할 때 구간 합은P[right]+P[left-1]입니다.

## 코드
~~~java
package java_algo;
import java.util.*;

public class Prefix_sum {
	public static int n =5;
	public static int arr[] = {10,20,30,40,50};
	public static int[] prefixSum = new int[6];
	
	
	public static void main(String[] args) {
		int sumValue = 0;
		
		for(int i =0;i <n;i++) {
			sumValue += arr[i];
			prefixSum[i + 1] = sumValue;
		}
		
		int left =3;
		int right = 4;
		System.out.println(prefixSum[right] - prefixSum[left -1]);

	}

}
~~~
------
# 트리
## 트리?
트리는 가계도와 같은 계층적인 구조를 표현할 때 사용할 수 있는 자료구조이다.

## 이진 탐색 트리(Binary Search Tree)
+ 이진 탐색이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조의 일종이다.
+ 이전 탐색 트리의 특징:왼쪽 자식 노드<부모 노드<오른쪽 자식 노드
  + 부모 노드보다 왼쪽 자식 노드가 작습니다.
  + 부모 노드보다 오른쪽 자식 노드가 큽니다.

# 트리의 순회(Tree Traversal)
+ 전위 순회:루트를 먼저 방문합니다.
+ 중위 순회:왼쪽 자식을 방문한 뒤에 루트를 방문합니다.
+ 후위 순회:오른쪽 자식을 방문한 뒤에 루트를 방문합니다.

------
# 해쉬(Hash)
+ 임의의 크기를 가진 데이터(key)를 고정된 크기의 데이터(Value)로 변화시켜 저장하는 것
+ 키에 대한 해시 값을 사용하여 값을 저장하고 키-값 쌍의 갯수에 따라 동적으로 크기가 증가하는 associate array
+ 키에 대한 해시값을 구하는 과정을 hashing(해싱)이라고 하며 이때 사용하는 함수(알고리즘)를 해시 함수라고 함.
+ 해시 값 자체를 index로 사용하기 때문에 평균 시간 복잡도가 O(1)로 매우 빠름

## 해쉬 함쉬(Hash Function)
+ 임의의 길이의 데이터를 입력받아 일정한 길이의 비트열로 반환시켜주는 함수
+ 원래의 값이나 키를 색인하는데 사용되며, 그 값이 관련된 데이터가 검색될 때마다 다시 사용된다.
+ 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
+ 계산이 복잡하지 않고 키값에 대해 중복없이 해시값을 고르게 만들어 내는 함수가 좋은 함수.**(충돌이 일어나지 않을수록 좋다.)**
+ 문자열을 받아서 숫자를 반환하는 함수(함수는 문자열에 대해 숫자를 할당(Mapping)

## 해싱(Hashing)
+ 키 값에 직접 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근
+ 매핑하는 과정을 말한다.
+ 해시 테이블을 이용하여 탐색한다.

## 해싱 과정
+ 키(KEY) ->해시 함수(HASH FUNCTION)->해시값(HASH VALUE)
  + 키(key):매핑 전 원래 데이터의 값,해시값:매핑 후 데이터의 값

## 해싱의 장점
+ 해시 충돌이라는 발생 가능성이 있지만, 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있음.
+ 하드디스크,클라우드 존재하는 데이터들은 무한에 가까운데, 이것들을 유한한 개수의 해시값으로 매핑하면서 작은 크기의 캐시메모리로도 프로세스를 관리할 수 있음.
+ 색인에 해시값을 사용하므로 모든 데이터를 살피지 않아도 검새과 삽입/삭제를 빠르게 수행
+ 해시 함수는 언제나 동일한 해시값을 리턴하고,해당 색인만 알면 해시테이블의 크기에 상관없이 데이터를 빠르게 접근 가능
+ 색인은 간단한 함수로 작동하기 때문에 매우 효율적
+ 데이터 엑세스시 시간 복잡도O(1)를 지향한다.
##  코드
~~~java
package java_algo;

public class Hash {
	static class Custom{
		String str;
		
		public Custom(String str) {
			this.str = str;
		}
	}
	public static void main(String[] args) {
		Custom a = new Custom("aaa");
		Custom b = new Custom("aaa");
		Custom c = a;
		
		System.out.println("a객체:"+a.hashCode());
		System.out.println("b객체:"+b.hashCode());
		System.out.println("c객체:"+c.hashCode());
		
	}

}
~~~
## 결과값
a객체:1528637575
b객체:1190524793
c객체:1528637575

-----
# 다이나믹 프로그래밍(Dynamic Programming)
## 다이나믹 프로그래밍?
+ 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상 시키는 방법입니다.
+ 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 합니다.
+ 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(탑다운과 바텀업)으로 구성됩니다.
+ 다이나믹 프로그래밍은 동적 계획법이라고도 부릅니다.
    ## 동적이라는 의미?
    + 자료구조에서 동적 할당(Dynamic Allocation)은 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법을 의미
    + 반면에 다이나믹 프로그래밍에서 ‘다이나믹’은 별다른 의미 없이 사용된 단어
  
## 다이나믹 문제가 사용될 때
1. 최적 부분 구조(Optimal Substructure)
    + 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다.
2. 중복되는 부분 문제(Overlapping Subproblem)
    + 동일한 작은 문제를 반복적으로 해결해야 합니다.
+ 대표적인 예:피보나치 수열